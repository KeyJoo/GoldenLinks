[{"html":"\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Vazhnoe_zamechanie\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Vazhnoe_zamechanie\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tВажное замечание\n\t\t\t\t\t</h3><blockquote>\n<p>Sapper ещё в ранней стадии разработки, и некоторые вещи могут поменяться, когда мы дойдём до релиза 1.0. Этот документ всё ещё дорабатывается. Если у вас появятся вопросы, обратитесь за помощью в русскоязычный <a href=\"https://t.me/sveltejs\" target=\"_blank\">Telegram-канал</a>.</p>\n<p>Прочтите <a href=\"migrating\">руководство по миграции</a> для помощи при обновлении с более старых версий.</p>\n</blockquote>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Chto_takoe_Sapper\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Chto_takoe_Sapper\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tЧто такое Sapper?\n\t\t\t\t\t</h3><p>Sapper — это фреймворк для создания невероятно производительных web-приложений. Прямо сейчас вы смотрите на одно из них! Вот два на наших основных принципа:</p>\n<ul>\n<li>Каждая страница вашего приложения является компонентом <a href=\"https://svelte.dev\" target=\"_blank\">Svelte</a></li>\n<li>Вы создаёте новые страницы путём добавления компонентов директорию <code>src/routes</code> вашего проекта. Они будут рендериться на сервере, так что время загрузки приложения для пользователем будет максимально быстрым, а уже затем клиентское приложение возьмёт на себя бразды правления.</li>\n</ul>\n<p>Создание приложения, соответствующего лучшим современным трендам, вроде разделения кода, поддержки автономного режима, гидратации — чрезвычайно сложная задача. Sapper делает все эти скучные вещи за вас, чтобы вы могли сконцентрироваться только на творческой части.</p>\n<p>Чтобы понять это руководство, знать Svelte не обязательно, но желательно. Svelte — это фреймворк, который компилирует ваши компоненты в высокооптимизированный ванильный JavaScript. Прочитайте <a href=\"https://svelte.dev/blog/svelte-3-rethinking-reactivity\" target=\"_blank\">вводную статью в блоге</a> и <a href=\"https://svelte.dev/tutorial\" target=\"_blank\">учебник</a>, чтобы узнать о нём побольше.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Otkuda_takoe_nazvanie\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Otkuda_takoe_nazvanie\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tОткуда такое название?\n\t\t\t\t\t</h3><p>В армии есть содаты, которые занимаются разминированием — <em>сапёры</em>. В американской армии тоже есть <em>sappers</em>, но их сфера деятельности намного шире — кроме разминирования, они ещё в боевых условиях строят мосты, ремонтируют дороги  и проводят сносы.</p>\n<p>Для веб-разработчиков ставки, как правило, ниже, чем для военных инженеров. Но у нас тоже есть враги с которыми мы должны бороться: недостаточно мощные устройства, медленные сетевые подключения и общая сложность проектирования интерфейсов. Sapper (скоращение от <b>S</b>velte <b>app</b> mak<b>er</b>) — это ваш мужественный и исполнительный солдат.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Sravnenie_s_Next_js\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Sravnenie_s_Next_js\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tСравнение с Next.js\n\t\t\t\t\t</h3><p><a href=\"https://github.com/zeit/next.js\" target=\"_blank\">Next.js</a> — это фреймворк для React от <a href=\"https://zeit.co\" target=\"_blank\">Zeit</a> и он является источником вдохновения для Sapper. Однако между ними есть несколько заметных отличий:</p>\n<ul>\n<li>Sapper работает на Svelte, а не на React, поэтому он быстрее и приложения получаются меньше по размеру</li>\n<li>Вместо маски маршрута мы используем описание параметров маршрута в именах файлов (см. Раздел <a href=\"docs#Marshruty\">Маршруты</a> ниже)</li>\n<li><em>Серверные</em> маршруты создаются точно так же, как и маршруты обычных <em>страниц</em> в директории <code>src/routes</code>. Например, это позволяет очень просто добавить точку входа для JSON API, такую же как есть на этой странице (попробуйте —  <a href=\"/docs.json\">/docs.json</a>)</li>\n<li>Ссылки — это обычные элементы <code>&lt;a&gt;</code>, а не специальные компоненты вроде <code>&lt;Link&gt;</code>. Это означает, например, что <a href=\"/\">эта ссылка</a>, прекрасно работает с маршрутизатором, даже не смотря на то, что она изначально располагается в импортированном документе с markdown разметкой.</li>\n</ul>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Nachalo_raboty\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Nachalo_raboty\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tНачало работы\n\t\t\t\t\t</h3><p>Самый простой способ начать создавать приложение Sapper — скопировать к себе на компьютер репеозиторий шаблона <a href=\"https://github.com/sveltejs/sapper-template\" target=\"_blank\">sapper-template</a> при помощи утилиты <a href=\"https://github.com/Rich-Harris/degit\" target=\"_blank\">degit</a>:</p>\n<div class=''><pre class='language-bash'><code>npx degit <span class=\"hljs-string\">\"sveltejs/sapper-template#rollup\"</span> my-app\n<span class=\"hljs-comment\"># или: npx \"degit sveltejs/sapper-template#webpack\" my-app</span>\n<span class=\"hljs-built_in\">cd</span> my-app\nnpm install\nnpm run dev</code></pre></div><p>Это создаст новый проект в каталоге <code>my-app</code>, установит его зависимости и запустит сервер на <a href=\"http://localhost:3000\" target=\"_blank\">localhost:3000</a>. Попробуйте поредактировать файлы, чтобы увидеть, насколько всё просто работает — быть может вам вообще не понадобиться читать оставшуюся часть этого руководства!</p>\n","metadata":{"title":"Введение"},"subsections":[{"slug":"Vazhnoe_zamechanie","title":"Важное замечание","level":3},{"slug":"Chto_takoe_Sapper","title":"Что такое Sapper?","level":3},{"slug":"Otkuda_takoe_nazvanie","title":"Откуда такое название?","level":3},{"slug":"Sravnenie_s_Next_js","title":"Сравнение с Next.js","level":3},{"slug":"Nachalo_raboty","title":"Начало работы","level":3}],"slug":"Vvedenie","file":"00-introduction.md"},{"html":"<p>Это просто раздел для любознательных.  Мы рекомендуем вам сначала поиграть с шаблоном проекта и вернуться сюда, когда прочувствуете как все вещи взаимосвязаны друг с другом.</p>\n<p>Если вы загляните в внутрь шаблона <a href=\"https://github.com/sveltejs/sapper-template\" target=\"_blank\">sapper-template</a>, вы увидите несколько файлов, которые Sapper ожидает там найти:</p>\n<div class=''><pre class='language-bash'><code>├ package.json\n├ src\n│ ├ routes\n│ │ ├ <span class=\"hljs-comment\"># тут ваши маршруты</span>\n│ │ ├ _error.svelte\n│ │ └ index.svelte\n│ ├ client.js\n│ ├ server.js\n│ ├ service-worker.js\n│ └ template.html\n├ static\n│ ├ <span class=\"hljs-comment\"># тут ваши картинки и прочая статика</span>\n└ rollup.config.js / webpack.config.js</code></pre></div><p>При первом запуске Sapper создаст дополнительный каталог <code>__sapper__</code>, содержащий сгенерированные файлы.</p>\n<p>Вы заметите несколько дополнительных файлов и каталог <code>cypress</code>, которые относятся к процессу <a href=\"docs#Testirovanie\">тестирования</a> — но в данный момент нам не нужно заострять на этом внимания.</p>\n<blockquote>\n<p>Вы можете <em>создать</em> эти файлы с нуля, но гораздо проще использовать готовый шаблон. См. раздел <a href=\"docs#Nachalo_raboty\">Начало работы</a> для получения инструкций о том, как легко развернуть шаблон на своём компьютере.</p>\n</blockquote>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"package_json\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#package_json\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tpackage.json\n\t\t\t\t\t</h3><p>Файл package.json содержит зависимости вашего приложения и определяет ряд скриптов:</p>\n<ul>\n<li><code>npm run dev</code> — запустить приложение в режиме разработки и следить за изменениями в исходных файлах</li>\n<li><code>npm run build</code> — собрать приложение для продакшена</li>\n<li><code>npm run export</code> — сгенерировать статическую версию приложениия, если это возможно (см. <a href=\"docs#Eksportirovanie\">Экспортирование</a>)</li>\n<li><code>npm start</code> — запустить приложение для продакшена, если оно уже было собрано до этого</li>\n<li><code>npm test</code> — запустить тесты (см. <a href=\"docs#Testirovanie\">Тестирование</a>)</li>\n</ul>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"src\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#src\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tsrc\n\t\t\t\t\t</h3><p>Тут содержатся три <em>точки входа</em> вашего приложения — <code>src/client.js</code>, <code>src/server.js</code> и (необязательно) <code>src/service-worker.js</code> — вместе с файлом <code>src/template.html</code>.</p>\n\n\t\t\t\t\t<h4>\n\t\t\t\t\t\t<span id=\"src_client_js\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#src_client_js\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tsrc/client.js\n\t\t\t\t\t</h4><p>Здесь <em>обязательно</em> нужно импортировать и вызвать функцию <code>start</code> из сгенерированного модуля <code>@sapper/app</code>:</p>\n<div class=''><pre class='language-javascript'><code><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> sapper <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@sapper/app'</span>;\n\nsapper.start({\n\t<span class=\"hljs-attr\">target</span>: <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">'#sapper'</span>)\n});</code></pre></div><p>Для большинства случаев это весь код модуля, но вы можете дополнительно написать здесь любой код под ваши нужды. Смотрите раздел <a href=\"docs#API_klienta\">API клиента</a> для получения дополнительной информации о функциях, которые вы можете импортировать.</p>\n\n\t\t\t\t\t<h4>\n\t\t\t\t\t\t<span id=\"src_server_js\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#src_server_js\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tsrc/server.js\n\t\t\t\t\t</h4><p>Это обычное Express приложение (можно взять <a href=\"https://github.com/lukeed/polka\" target=\"_blank\">Polka</a> или ещё какой-либо сервер), с тремя обязательными требованиями:</p>\n<ul>\n<li>оно должно сервить содержимое папки <code>static</code>, используя, например, <a href=\"https://github.com/lukeed/sirv\" target=\"_blank\">sirv</a></li>\n<li>оно должен вызвать <code>app.use(sapper.middleware())</code> в том месте, где <code>sapper</code> импортируется из <code>@sapper/server</code></li>\n<li>оно должно &#39;висеть&#39; на порту, указанном в <code>process.env.PORT</code></li>\n</ul>\n<p>В остальном, вы можете написать сервер так, как вам нравится.</p>\n\n\t\t\t\t\t<h4>\n\t\t\t\t\t\t<span id=\"src_service-worker_js\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#src_service-worker_js\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tsrc/service-worker.js\n\t\t\t\t\t</h4><p>Сервис-воркеры действуют как прокси-серверы, которые дают вам детальный контроль над тем, как реагировать на сетевые запросы. Например, когда браузер запрашивает <code>/козлики.jpg</code>, сервис-воркер может вернуть файл, который он уже ранее закешировал, или он может передать запрос на сервер, или он может даже ответить чем-то совершенно другим, например, картинкой оленей.</p>\n<p>Помимо прочего, они позволяют создавать приложения, работающие в автономном режиме.</p>\n<p>Поскольку каждому приложению требуется особое поведение сервис-воркеров (одним надо всё отдавать из кэша, другим кеш нужен только при отсутствии подключения), Sapper никак не ограничивает поведение сервис-воркеров. Вы сами пишете его логику в <code>service-worker.js</code>. Вы можете импортировать любой из следующих объектов из <code>@sapper/service-worker</code>:</p>\n<ul>\n<li><code>files</code> — массив файлов, найденных в директории <code>static</code></li>\n<li><code>shell</code> — JavaScript код для клиента, сгенерированный сборщиком(Rollup или webpack)</li>\n<li><code>routes</code> — массив объектов <code>{ pattern: RegExp }</code>, которые вы можете использовать, чтобы определить относится ли к Sapper запрошенная страница</li>\n<li><code>timestamp</code> — время, когда был создан сервис-воркер(полезно для создания уникальных имён кэшей)</li>\n</ul>\n\n\t\t\t\t\t<h4>\n\t\t\t\t\t\t<span id=\"src_template_html\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#src_template_html\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tsrc/template.html\n\t\t\t\t\t</h4><p>Этот файл является шаблоном для ответов с сервера. В процессе сборки Sapper будет внедрять контент, заменяющий следующие метки:</p>\n<ul>\n<li><code>%sapper.base%</code> — элемент <code>&lt;base&gt;</code> (см. <a href=\"docs#Bazovye_URL\">Базовые URL</a>)</li>\n<li><code>%sapper.styles%</code> — необходимый CSS для запрашиваемой страницы</li>\n<li><code>%sapper.head%</code> — HTML представление специфичного для данной страницы содержимого элемента <code>&lt;head&gt;</code>, вроде элемента <code>&lt;title&gt;</code></li>\n<li><code>%sapper.html%</code> — HTML представление содержимого отрендеренной страницы</li>\n<li><code>%sapper.scripts%</code> — элементы <code>&lt;script&gt;</code> для клиентской части приложения</li>\n</ul>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"src_routes\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#src_routes\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tsrc/routes\n\t\t\t\t\t</h3><p>Это основа вашего приложения — страницы и маршруты сервера. Подробнее вы узнаете в разделе <a href=\"docs#Marshruty\">Маршруты</a>.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"static\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#static\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tstatic\n\t\t\t\t\t</h3><p>Это место для размещения любых файлов, которые использует ваше приложение — шрифты, изображения и так далее. Например, <code>static/favicon.png</code> будет доступна как <code>/favicon.png</code>.</p>\n<p>Sapper не будет сервить эти файлы. Обычно для этого используют <a href=\"https://github.com/lukeed/sirv\" target=\"_blank\">sirv</a> или <a href=\"https://github.com/expressjs/serve-static\" target=\"_blank\">serve-static</a>. Но он будет сканировать содержимое папки <code>static</code>, чтобы вы могли легко сгенерировать манифест кэша для поддержки автономной работы(см. <a href=\"docs#templates-service-worker-js\">service-worker.js</a>).</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"rollup_config_js_webpack_config_js\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#rollup_config_js_webpack_config_js\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\trollup.config.js / webpack.config.js\n\t\t\t\t\t</h3><p>Sapper может использовать <a href=\"https://rollupjs.org/\" target=\"_blank\">Rollup</a> или <a href=\"https://webpack.js.org/\" target=\"_blank\">webpack</a> для сборки вашего приложения. Скорее всего, вам не понадобится менять их конфигурацию, но при необходимости, вы, конечно, можете, например, добавить новый плагин.</p>\n","metadata":{"title":"Структура приложения"},"subsections":[{"slug":"package_json","title":"package.json","level":3},{"slug":"src","title":"src","level":3},{"slug":"src_client_js","title":"src/client.js","level":4},{"slug":"src_server_js","title":"src/server.js","level":4},{"slug":"src_service-worker_js","title":"src/service-worker.js","level":4},{"slug":"src_template_html","title":"src/template.html","level":4},{"slug":"src_routes","title":"src/routes","level":3},{"slug":"static","title":"static","level":3},{"slug":"rollup_config_js_webpack_config_js","title":"rollup.config.js / webpack.config.js","level":3}],"slug":"Struktura_prilozheniya","file":"01-structure.md"},{"html":"<p>Как мы уже видели, в Sapper есть два типа маршрутов — маршруты страниц и маршруты сервера.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Straniczy\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Straniczy\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tСтраницы\n\t\t\t\t\t</h3><p>Страницы — это компоненты Svelte, описанные в файлах <code>.svelte</code>. Когда пользователь впервые посещает приложение, ему будет предоставлена сгенерирования на сервере версия запрошенного маршрута, а также некоторый JavaScript, который выполняет &#39;гидратацию&#39; страницы и инициализирует маршрутизатор на стороне клиента. С этого момента навигация на другие страницы будет полностью выполняться на стороне клиента обеспечивая очень быстрое перемещение, что типично для клиентских приложений.</p>\n<p>Имя файла определяет маршрут. Например, <code>src/routes/index.svelte</code> — корневой файл вашего сайта:</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-comment\">&lt;!-- src/routes/index.svelte --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svelte:head</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Добро пожаловать!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svelte:head</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Приветствую вас на моём сайте!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></code></pre></div><p>Файл с именем <code>src/routes/about.svelte</code> или <code>src/routes/about/index.svelte</code> будет соответствовать маршруту <code>/about</code>:</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-comment\">&lt;!-- src/routes/about.svelte --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svelte:head</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>О сайте<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svelte:head</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Информация о сайте<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Это самый лучший сайт!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre></div><p>Динамические параметры задаются при помощи квадратных скобок <code>[...]</code>. Например, таким образом можно сделать страницу, отображающую статью из блога:</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-comment\">&lt;!-- src/routes/blog/[slug].svelte --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">context</span>=<span class=\"hljs-string\">\"module\"</span>&gt;</span><span class=\"javascript\">\n\t<span class=\"hljs-comment\">// необязательная функция preload принимает объект</span>\n\t<span class=\"hljs-comment\">// `{ path, params, query }` и превращает его в</span>\n\t<span class=\"hljs-comment\">// данные, которые надо отрисовать на странице</span>\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">preload</span>(<span class=\"hljs-params\">page, session</span>) </span>{\n\t\t<span class=\"hljs-comment\">// у нас есть доступ к параметру `slug`, потому что</span>\n\t\t<span class=\"hljs-comment\">// файл называется [slug].html</span>\n\t\t<span class=\"hljs-keyword\">const</span> { slug } = page.params;\n\n\t\t<span class=\"hljs-comment\">// `this.fetch` — это обертка для `fetch`, которая</span>\n\t\t<span class=\"hljs-comment\">// позволяет выполнять легитимные запросы</span>\n\t\t<span class=\"hljs-comment\">// как с сервера, так и с клиента</span>\n\t\t<span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">this</span>.fetch(<span class=\"hljs-string\">`blog/<span class=\"hljs-subst\">${slug}</span>.json`</span>);\n\t\t<span class=\"hljs-keyword\">const</span> article = <span class=\"hljs-keyword\">await</span> res.json();\n\n\t\t<span class=\"hljs-keyword\">return</span> { article };\n\t}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> article;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svelte:head</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>{article.title}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svelte:head</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>{article.title}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">'content'</span>&gt;</span>\n\t{@html article.html}\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre></div><blockquote>\n<p>Подробнее о функциях <code>preload</code> и <code>this.fetch</code>  мы узнаем в разделе <a href=\"docs#Predzagruzka\">Предзагрузка</a></p>\n</blockquote>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Marshruty_servera\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Marshruty_servera\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tМаршруты сервера\n\t\t\t\t\t</h3><p>Серверные маршруты — это модули, написанные в файлах <code>.js</code>, которые экспортируют функции, соответствующие HTTP методам. Каждая функция получает в качестве аргументов объекты HTTP <code>request</code> и <code>response</code>, а также функцию <code>next</code>. Это полезно для создания JSON API. Например, вот как бы вы могли бы создать эндпоинт для обслуживания страницы блога выше:</p>\n<div class=''><pre class='language-javascript'><code><span class=\"hljs-comment\">// routes/blog/[slug].json.js</span>\n<span class=\"hljs-keyword\">import</span> db <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./_database.js'</span>; <span class=\"hljs-comment\">// нижнее подчёркивание, говорит Sapper, что это не маршрут</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">get</span>(<span class=\"hljs-params\">req, res, next</span>) </span>{\n\t<span class=\"hljs-comment\">// у нас есть доступ к параметру `slug`, потому что</span>\n\t<span class=\"hljs-comment\">// файл называется [slug].json.js</span>\n\t<span class=\"hljs-keyword\">const</span> { slug } = req.params;\n\n\t<span class=\"hljs-keyword\">const</span> article = <span class=\"hljs-keyword\">await</span> db.get(slug);\n\n\t<span class=\"hljs-keyword\">if</span> (article !== <span class=\"hljs-literal\">null</span>) {\n\t\tres.setHeader(<span class=\"hljs-string\">'Content-Type'</span>, <span class=\"hljs-string\">'application/json'</span>);\n\t\tres.end(<span class=\"hljs-built_in\">JSON</span>.stringify(article));\n\t} <span class=\"hljs-keyword\">else</span> {\n\t\tnext();\n\t}\n}</code></pre></div><blockquote>\n<p><code>delete</code> — зарезервированное слово в JavaScript. Для обработки запросов DELETE экспортируйте функцию с именем <code>del</code>.</p>\n</blockquote>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Pravila_imenovaniya_fajlov\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Pravila_imenovaniya_fajlov\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tПравила именования файлов\n\t\t\t\t\t</h3><p>Существует три простых правила именования файлов, которые определяют ваши маршруты:</p>\n<ul>\n<li>Файл с именем <code>src/routes/about.svelte</code> соответствует маршруту <code>/about</code>. Файл с именем <code>src/routes/blog/[slug].svelte</code> соответствует маршруту <code>/blog/:slug</code>, и в этом случае <code>params.slug</code> доступен для <code>preload</code></li>\n<li>Файл <code>src/routes/index.svelte</code> соответствует корню вашего сайта. <code>src/routes/about/index.svelte</code> обрабатывается так же, как <code>src/routes/about.svelte</code>.</li>\n<li>Файлы и каталоги начинающиеся с нижнего подчёркивания <em>не</em> создают маршруты. Это позволяет объединять вспомогательные модули и компоненты с маршрутами, которые зависят от них — например, у вас может быть файл с именем <code>src/routes/_helpers/datetime.js</code>, но маршрут <code>/_helpers/datetime</code> <em>не</em> будет создан</li>\n</ul>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Stranicza_s_oshibkoj\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Stranicza_s_oshibkoj\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tСтраница с ошибкой\n\t\t\t\t\t</h3><p>В дополнение к обычным страницам есть специальная страница, которую Sapper ожидает найти по пути — <code>src/routes/_error.svelte</code>. Она будет показана, если возникнет ошибка при отображении запрошенной страницы.</p>\n<p>В шаблоне будет доступен объект <code>error</code> и код HTTP статуса в <code>status</code>.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Regulyarnye_vyrazheniya_v_marshrutah\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Regulyarnye_vyrazheniya_v_marshrutah\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tРегулярные выражения в маршрутах\n\t\t\t\t\t</h3><p>Вы можете использовать регулярные выражения для указания параметров маршрута, поместив их в скобки после имени параметра.</p>\n<p>Например, <code>src/routes/items/[id([0-9]+)].svelte</code> будет соответствовать только числовым идентификаторам — <code>/items/123</code>, а маршрут <code>/items/xyz</code> не пройдёт.</p>\n<p>Из-за технических особенностей, в регулярных выражениях невозможно использовать следующие символы: <code>/</code>, <code>\\</code>, <code>?</code>, <code>:</code>, <code>(</code> and <code>)</code>.</p>\n","metadata":{"title":"Маршруты"},"subsections":[{"slug":"Straniczy","title":"Страницы","level":3},{"slug":"Marshruty_servera","title":"Маршруты сервера","level":3},{"slug":"Pravila_imenovaniya_fajlov","title":"Правила именования файлов","level":3},{"slug":"Stranicza_s_oshibkoj","title":"Страница с ошибкой","level":3},{"slug":"Regulyarnye_vyrazheniya_v_marshrutah","title":"Регулярные выражения в маршрутах","level":3}],"slug":"Marshruty","file":"02-routing.md"},{"html":"<p>Модуль <code>@sapper/app</code>, который генерирует Sapper на основе вашего струкутры приложения, содержит функции для управления Sapper из кода и реагирования на события.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"start_target\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#start_target\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tstart({ target })\n\t\t\t\t\t</h3><ul>\n<li><code>target</code> — елемент, в который будут отрисовываться страницы</li>\n</ul>\n<p>Настраивает маршрутизатор и запускает приложение — отлавливает клики по элементам <code>&lt;a&gt;</code>, взаимодействует с <code>history API</code>, отображает и обновляет компоненты Svelte.</p>\n<p>Возвращает объект <code>Promise</code>, который выполняется, когда загруженная страница закончит &#39;гидратацию&#39;.</p>\n<div class=''><pre class='language-javascript'><code><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> sapper <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@sapper/app'</span>;\n\nsapper.start({\n\t<span class=\"hljs-attr\">target</span>: <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">'#sapper'</span>)\n}).then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n\t<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'клиентское приложение запустилось'</span>);\n});</code></pre></div>\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"goto_href_options\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#goto_href_options\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tgoto(href, options?)\n\t\t\t\t\t</h3><ul>\n<li><code>href</code> — страница, на которую надо перейти</li>\n<li><code>options</code> — может включать свойство <code>replaceState</code>, которое определяет, использовать ли <code>history.pushState</code> (по умолчанию) или <code>history.replaceState</code>. Не обязательно.</li>\n</ul>\n<p>Перемещает по заданному в <code>href</code> маршруту. Если пунктом назначения является маршрут Sapper, то Sapper перехватит и отработает перемещение, в ином случае страница будет просто перезагружена с новым <code>href</code>. Иначе говоря, это ничем не отличается от поведения, когда пользователь просто кликает по ссылке с таким-же <code>href</code> атрибутом.</p>\n<p>Возвращает объект <code>Promise</code>, который разрешается, когда перемещение будет завершено.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"prefetch_href\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#prefetch_href\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tprefetch(href)\n\t\t\t\t\t</h3><ul>\n<li><code>href</code> — страница для упреждающей загрузки</li>\n</ul>\n<p>Выполняет упреждающую загрузку указанной страницы, что означает: а) обеспечение полной загрузки кода для страницы и б) вызов метода <code>preload</code> страницы с соответствующими параметрами. Это поведение, аналогично случаю, когда пользователь тапает или в проводит курсором над элементом <code>&lt;a&gt;</code> с установленным атрибутом <a href=\"docs#Uprezhdayushhaya_zagruzka\">rel=prefetch</a>.</p>\n<p>Возвращает объект <code>Promise</code>, который разрешается, когда упреждающая загрузка будет завершена.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"prefetchRoutes_routes\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#prefetchRoutes_routes\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tprefetchRoutes(routes?)\n\t\t\t\t\t</h3><ul>\n<li><code>routes</code> —  массив строк, маршрутов для упреждающей загрузки. Не обязательно.</li>\n</ul>\n<p>Выполняет упреждающую загрузку кода для маршрутов, которые ещё не были загружены до этого. Обычно вызывается после завершения <code>sapper.start()</code>, чтобы ускорить последующую навигацию (это реализует букву &#39;L&#39; в <a href=\"https://developers.google.com/web/fundamentals/performance/prpl-pattern/\" target=\"_blank\">PRPL шаблоне</a>).  Вы можете указать маршруты по любому подходящему пути, например, <code>/about</code> (для  <code>src/routes/about.svelte</code>) или <code>/blog/*</code> (для <code>src/routes/blog/[slug].svelte</code>). В отличие от <code>prefetch</code>, это не вызовет функцию <code>preload</code> для каждой из загружаемых страниц.  Вызов функции без аргументов приведёт к тому, что будут загружены все маршруты.</p>\n<p>Возвращает объект <code>Promise</code>, который разрешается, когда упреждающая загрузка всех маршрутов будет завершена.</p>\n","metadata":{"title":"API клиента"},"subsections":[{"slug":"start_target","title":"start({ target })","level":3},{"slug":"goto_href_options","title":"goto(href, options?)","level":3},{"slug":"prefetch_href","title":"prefetch(href)","level":3},{"slug":"prefetchRoutes_routes","title":"prefetchRoutes(routes?)","level":3}],"slug":"API_klienta","file":"03-client-api.md"},{"html":"<p>Как мы видели в разделе <a href=\"docs#Marshruty\">Маршруты</a>, компоненты страниц верхнего уровня могут иметь функцию <code>preload</code>, которая будет загружать некоторые данные, от которых зависит страница. Она похожа на <code>getInitialProps</code> в Next.js или <code>asyncData</code> в Nuxt.js.</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">context</span>=<span class=\"hljs-string\">\"module\"</span>&gt;</span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">preload</span>(<span class=\"hljs-params\">page, session</span>) </span>{\n\t\t<span class=\"hljs-keyword\">const</span> { slug } = page.params;\n\n\t\t<span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">this</span>.fetch(<span class=\"hljs-string\">`blog/<span class=\"hljs-subst\">${slug}</span>.json`</span>);\n\t\t<span class=\"hljs-keyword\">const</span> article = <span class=\"hljs-keyword\">await</span> res.json();\n\n\t\t<span class=\"hljs-keyword\">return</span> { article };\n\t}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre></div><p>Она помещается в блоке <code>&lt;script context=&quot;module&quot;&gt;</code>, потому что он не является частью экземпляров компонентов; вместо этого он выполняется <em>до</em> создания компонента, что позволяет избежать морганий компонента во время выборки данных. Подробнее в <a href=\"https://ru.svelte.dev/tutorial/module-exports\" target=\"_blank\">Учебнике</a></p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Argumenty\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Argumenty\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tАргументы\n\t\t\t\t\t</h3><p>В функцию <code>preload</code> передаётся два аргумента — <code>page</code> и <code>session</code>.</p>\n<p><code>page</code> является объектом <code>{ host, path, params, query }</code>, где <code>host</code> и <code>path</code>— это соответственно часть хоста и путь из URL, <code>params</code> выводится из URL и имени файла маршрута, а <code>query</code> является объектом значений из строки запроса..</p>\n<p>Для примера рассмотрим знакомую страницу <code>src/routes/blog/[slug].svelte</code>. Предположим, к ней обратились по а URL-адресу вида <code>/blog/some-post?foo=bar&amp;baz</code>, тогда мы получим следующие данные:</p>\n<ul>\n<li><code>page.path === &#39;/blog/some-post&#39;</code></li>\n<li><code>page.params.slug === &#39;some-post&#39;</code></li>\n<li><code>page.query.foo === &#39;bar&#39;</code></li>\n<li><code>page.query.baz === true</code></li>\n</ul>\n<p><code>session</code> генерируется на сервере путём передачи параметра <code>session</code> в <code>sapper.middleware</code> (TODO это требует дополнительной документации. Возможно будет раздел API сервера?)</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Vozvrashhaemoe_znachenie\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Vozvrashhaemoe_znachenie\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tВозвращаемое значение\n\t\t\t\t\t</h3><p>Если вы вернёте промис из <code>preload</code>, страница не будет отображаться, пока промис не исполнится. Но вы также можете вернуть и простой объект.</p>\n<p>Когда Sapper ренедерит страницу на сервере, он пытается сериализовать полученное значение (используя <a href=\"https://github.com/Rich-Harris/devalue\" target=\"_blank\">devalue</a>) и помещает его на страницу, поэтому клиентской части нет необходимости повторно вызывать <code>preload</code> при инициализации. Сериализация выдаст ошибку, если значение включает функции или пользовательские классы (но можно использовать циклические и повторяющиеся ссылки, а также встроенные модули, типа <code>Date</code>,<code>Map</code>, <code>Set</code> и <code>RegExp</code>).</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Kontekst\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Kontekst\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tКонтекст\n\t\t\t\t\t</h3><p>Внутри функции <code>preload</code> у вас есть доступ к трём методам ...</p>\n<ul>\n<li><code>this.fetch(url, options)</code></li>\n<li><code>this.error(statusCode, error)</code></li>\n<li><code>this.redirect(statusCode, location)</code></li>\n</ul>\n\n\t\t\t\t\t<h4>\n\t\t\t\t\t\t<span id=\"this_fetch\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#this_fetch\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tthis.fetch\n\t\t\t\t\t</h4><p>В браузерах вы можете использовать <code>fetch</code> для выполнения AJAX запросов, например, для получения данных с ваших серверных маршрутов. На сервере это несколько сложнее — вы можете делать HTTP-запросы, но нужно прописать origin, и у вас нет доступа к файлам cookie. Это означает, что невозможно запрашивать данные, основанные на сеансе пользователя, например, требующих входа в систему.</p>\n<p>Чтобы исправить это, Sapper предлагает функцию <code>this.fetch</code>, которая работает одинаково как на сервере, так и на клиенте:</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">context</span>=<span class=\"hljs-string\">\"module\"</span>&gt;</span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">preload</span>(<span class=\"hljs-params\"></span>) </span>{\n\t\t<span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">this</span>.fetch(<span class=\"hljs-string\">`secret-data.json`</span>, {\n\t\t\t<span class=\"hljs-attr\">credentials</span>: <span class=\"hljs-string\">'include'</span>\n\t\t});\n\n\t\t<span class=\"hljs-comment\">// ...</span>\n\t}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre></div><p>Обратите внимание, что вам нужно будет использовать какую-либо прослойку для управления сессиями  в вашем <code>app/server.js</code>, чтобы обрабатывать сеансы пользователей или делать что-либо, связанное с аутентификацией. Например <a href=\"https://github.com/expressjs/session\" target=\"_blank\">express-session</a>.</p>\n\n\t\t\t\t\t<h4>\n\t\t\t\t\t\t<span id=\"this_error\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#this_error\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tthis.error\n\t\t\t\t\t</h4><p>Если пользователь перейдёт на <code>/blog/some-invalid-slug</code>, хотелось бы ему показать страницу с ошибкой &#39;404 — страница не найдена&#39;. И мы можем сделать это с помощью <code>this.error</code>:</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">context</span>=<span class=\"hljs-string\">\"module\"</span>&gt;</span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">preload</span>(<span class=\"hljs-params\">{ params, query }</span>) </span>{\n\t\t<span class=\"hljs-keyword\">const</span> { slug } = params;\n\n\t\t<span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">this</span>.fetch(<span class=\"hljs-string\">`blog/<span class=\"hljs-subst\">${slug}</span>.json`</span>);\n\n\t\t<span class=\"hljs-keyword\">if</span> (res.status === <span class=\"hljs-number\">200</span>) {\n\t\t\t<span class=\"hljs-keyword\">const</span> article = <span class=\"hljs-keyword\">await</span> res.json();\n\t\t\t<span class=\"hljs-keyword\">return</span> { article };\n\t\t}\n\n\t\t<span class=\"hljs-keyword\">this</span>.error(<span class=\"hljs-number\">404</span>, <span class=\"hljs-string\">'Страница не найдена'</span>);\n\t}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre></div><p>Аналогичным образом обрабатываются и другие коды ошибок, с которыми вы можете столкнуться.</p>\n\n\t\t\t\t\t<h4>\n\t\t\t\t\t\t<span id=\"this_redirect\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#this_redirect\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tthis.redirect\n\t\t\t\t\t</h4><p>Вы можете прервать отрисовку и перенаправить пользователя в другое место с помощью <code>this.redirect</code>:</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">context</span>=<span class=\"hljs-string\">\"module\"</span>&gt;</span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">preload</span>(<span class=\"hljs-params\">page, session</span>) </span>{\n\t\t<span class=\"hljs-keyword\">const</span> { user } = session;\n\n\t\t<span class=\"hljs-keyword\">if</span> (!user) {\n\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.redirect(<span class=\"hljs-number\">302</span>, <span class=\"hljs-string\">'login'</span>);\n\t\t}\n\n\t\t<span class=\"hljs-keyword\">return</span> { user };\n\t}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre></div>","metadata":{"title":"Предзагрузка"},"subsections":[{"slug":"Argumenty","title":"Аргументы","level":3},{"slug":"Vozvrashhaemoe_znachenie","title":"Возвращаемое значение","level":3},{"slug":"Kontekst","title":"Контекст","level":3},{"slug":"this_fetch","title":"this.fetch","level":4},{"slug":"this_error","title":"this.error","level":4},{"slug":"this_redirect","title":"this.redirect","level":4}],"slug":"Predzagruzka","file":"04-preloading.md"},{"html":"<p>До сих пор мы рассматривали страницы как полностью автономные компоненты — при переходе между страницами существующий компонент уничтожался, а новый занимал его место.</p>\n<p>Но во многих приложениях есть элементы, которые должны быть видны на <em>каждой</em> странице, такие как навигация или подвал. Вместо того, чтобы повторять их на каждой странице, мы можем использовать компоненты <em>макета</em>.</p>\n<p>Чтобы создать компонент макета, который будет применяться к каждой странице приложения, создайте файл с именем <code>src/routes/_layout.svelte</code>. По умолчанию компонент макета (такой же будет использовать Sapper, если не будет этого файла) выглядит следующим образом...</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span></code></pre></div><p>...но мы можем добавить любую разметку, стили и поведение, которые мы хотим. Например, давайте добавим панель навигациии:</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-comment\">&lt;!-- src/routes/_layout.svelte --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\".\"</span>&gt;</span>Главная<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"about\"</span>&gt;</span>О сайте<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"settings\"</span>&gt;</span>Настройки<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span></code></pre></div><p>Если мы создадим страницы для <code>/</code>, <code>/about</code> и <code>/settings</code>...</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-comment\">&lt;!-- src/routes/index.svelte --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Главная<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></code></pre></div><div class=''><pre class='language-markup'><code><span class=\"hljs-comment\">&lt;!-- src/routes/about.svelte --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>О сайте<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></code></pre></div><div class=''><pre class='language-markup'><code><span class=\"hljs-comment\">&lt;!-- src/routes/settings.svelte --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Настройки<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></code></pre></div><p>...навигация всегда будет видна, и переход между тремя страницами приведёт только к замене содержимого элемента <code>&lt;h1&gt;</code>.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Vlozhennye_marshruty\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Vlozhennye_marshruty\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tВложенные маршруты\n\t\t\t\t\t</h3><p>Предположим, что у нас не просто одна страница <code>/settings</code>, а есть и вложенные страницы, вроде <code>/settings/profile</code> и <code>/settings/notifications</code> с общим подменю (для реального примера см. <a href=\"https://github.com/settings\" target=\"_blank\">github.com/settings</a>).</p>\n<p>Мы можем создать макет, который применяется только к страницам, расположенным ниже <code>/settings</code> (при этом останется и корневой макет с навигацией):</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-comment\">&lt;!-- src/routes/settings/_layout.svelte --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Настройки<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"submenu\"</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"settings/profile\"</span>&gt;</span>Профиль<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"settings/notifications\"</span>&gt;</span>Уведомления<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span></code></pre></div><p>Компонентам макета передаётся свойство <code>segment</code>, которое может быть полезно, например, для стилизации:</p>\n<div class=''><pre class='language-undefined'><code><span class=\"hljs-addition\">+&lt;script&gt;</span>\n<span class=\"hljs-addition\">+    export let segment;</span>\n<span class=\"hljs-addition\">+&lt;/script&gt;</span>\n<span class=\"hljs-addition\">+</span>\n&lt;div class=\"submenu\"&gt;\n<span class=\"hljs-deletion\">-    &lt;a href=\"settings/profile\"&gt;Профиль&lt;/a&gt;</span>\n<span class=\"hljs-deletion\">-    &lt;a href=\"settings/notifications\"&gt;Уведомления&lt;/a&gt;</span>\n<span class=\"hljs-addition\">+    &lt;a</span>\n<span class=\"hljs-addition\">+        class:selected={segment === \"profile\"}</span>\n<span class=\"hljs-addition\">+        href=\"settings/profile\"</span>\n<span class=\"hljs-addition\">+    &gt;Профиль&lt;/a&gt;</span>\n<span class=\"hljs-addition\">+</span>\n<span class=\"hljs-addition\">+    &lt;a</span>\n<span class=\"hljs-addition\">+        class:selected={segment === \"notifications\"}</span>\n<span class=\"hljs-addition\">+        href=\"settings/notifications\"</span>\n<span class=\"hljs-addition\">+    &gt;Уведомления&lt;/a&gt;</span>\n&lt;/div&gt;</code></pre></div>","metadata":{"title":"Макеты"},"subsections":[{"slug":"Vlozhennye_marshruty","title":"Вложенные маршруты","level":3}],"slug":"Makety","file":"05-layouts.md"},{"html":"<p>По умолчанию, Sapper рендерит сначала серверную часть (SSR), а затем заново монтирует любые динамические элементы на стороне клиента. Svelte отлично <a href=\"https://ru.svelte.dev/docs#API_komponenta_na_servere\" target=\"_blank\">поддерживает SSR</a>. Среди достоинств рендеринга на сервере — лучшая производительность и более качественная индексация сайта поисковыми системами, но вместе с тем есть и некоторые сложности.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Sozdanie_komponenta_sovmestimogo_s_SSR\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Sozdanie_komponenta_sovmestimogo_s_SSR\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tСоздание компонента совместимого с SSR\n\t\t\t\t\t</h3><p>Sapper хорошо работает с большинством сторонних библиотек, с которыми вы можете столкнуться. Однако иногда сторонняя библиотека поставляется собранной с прицелом на работу сразу с несколькими различными загрузчиками модулей. Иногда такой подход создаёт зависимость от объекта <code>window</code>, например, может проверяться на существование свойство <code>window.global</code>.</p>\n<p>Поскольку в серверной среде, такой как Sapper, нет <code>window</code>, действие простого импорта такого модуля может привести к сбою импорта и завершить работу сервера Sapper с ошибкой:</p>\n<div class=''><pre class='language-bash'><code>ReferenceError: window is not defined</code></pre></div><p>Чтобы избежать таких ошибок, используйте динамический импорт для вашего компонента из функции <code>onMount</code>, который вызывается только на стороне клиента. В этом случае, код импорта никогда не будет вызван на сервере:</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">import</span> { onMount } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'svelte'</span>;\n\n\t<span class=\"hljs-keyword\">let</span> MyComponent;\n\n\tonMount(<span class=\"hljs-keyword\">async</span> () =&gt; {\n\t\t<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">module</span> = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">'my-non-ssr-component'</span>);\n\t\tMyComponent = <span class=\"hljs-built_in\">module</span>.default;\n\t});\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svelte:component</span> <span class=\"hljs-attr\">this</span>=<span class=\"hljs-string\">{MyComponent}</span> <span class=\"hljs-attr\">foo</span>=<span class=\"hljs-string\">\"bar\"</span>/&gt;</span></code></pre></div>","metadata":{"title":"Ренедринг на стороне сервера (SSR)"},"subsections":[{"slug":"Sozdanie_komponenta_sovmestimogo_s_SSR","title":"Создание компонента совместимого с SSR","level":3}],"slug":"Renedring_na_storone_servera_SSR","file":"06-server-side-rendering.md"},{"html":"<p>Значения <code>page</code> и <code>session</code>, передаваемые в функции <code>preload</code>, а так же <code>preloading</code>, доступны компонентам как <a href=\"https://ru.svelte.dev/tutorial/writable-stores\" target=\"_blank\">хранилища</a>.</p>\n<p>Получение ссылок на хранилища внутри компонента выглядит следующим образом:</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">import</span> { stores } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@sapper/app'</span>;\n\t<span class=\"hljs-keyword\">const</span> { preloading, page, session } = stores();\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre></div><ul>\n<li><code>preloading</code> булевое значение только для чтения, показывающее идет ли еще процесс загрузки после перехода</li>\n<li><code>page</code> содержит объект <code>{path, params, query}</code>, только для чтения. Аналогичен объекту, передаваемому функции <code>preload</code>.</li>\n<li><code>session</code> содержит любые данные сессии, которые были оставлены на сервере. Это <a href=\"https://ru.svelte.dev/tutorial/writable-stores\" target=\"_blank\">доступное для записи хранилище</a>, то есть вы можете обновить его новыми данными (например, после входа пользователя в систему), затем приложение будет перерисовано.</li>\n</ul>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Obnovlenie_dannyh_sessii\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Obnovlenie_dannyh_sessii\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tОбновление данных сессии\n\t\t\t\t\t</h3><p>На сервере можно заполнить данными <code>session</code>, передав соответствующий параметр в <code>sapper.middleware</code>:</p>\n<div class=''><pre class='language-javascript'><code><span class=\"hljs-comment\">// src/server.js</span>\nexpress() <span class=\"hljs-comment\">// или Polka, или похожий фреймворк</span>\n\t.use(\n\t\tserve(<span class=\"hljs-string\">'static'</span>),\n\t\tauthenticationMiddleware(),\n\t\tsapper.middleware({\n\t\t\t<span class=\"hljs-attr\">session</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> ({\n\t\t\t\t<span class=\"hljs-attr\">user</span>: req.user\n\t\t\t})\n\t\t})\n\t)\n\t.listen(process.env.PORT);</code></pre></div><blockquote>\n<p>Данные сессии должны быть сериализуемыми(используется <a href=\"https://github.com/Rich-Harris/devalue\" target=\"_blank\">devalue</a>) — никаких функций или пользовательских классов, только встроенные в JavaScript типы данных</p>\n</blockquote>\n","metadata":{"title":"Хранилища"},"subsections":[{"slug":"Obnovlenie_dannyh_sessii","title":"Обновление данных сессии","level":3}],"slug":"Hranilishha","file":"07-state-management.md"},{"html":"<p>Для обеспечения быстрого времени запуска приложения, Sapper использует разделение кода, чтобы разбить ваше приложение на небольшие части.</p>\n<p>Для <em>динамических</em> маршрутов, вроде нашего примера <code>src/routes/blog/[slug].svelte</code>, этого бывает недостаточно. Чтобы отобразить сообщение в блоге, нам нужно получить для него данные, и мы не сможем этого сделать, пока не узнаем значение для <code>slug</code>. В худшем случае, это приведёт к задержке отображения страницы, так как браузер будет ожидать получения запрошенных данных от сервера.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"rel_prefetch\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#rel_prefetch\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\trel=prefetch\n\t\t\t\t\t</h3><p>Мы можем свести задержку к минимуму, <em>предварительно запросив</em> нужные данные. Добавление атрибута <code>rel=prefetch</code> в ссылку...</p>\n<div class=''><pre class='language-markup'><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">prefetch</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">'blog/what-is-sapper'</span>&gt;</span>Что такое Sapper?<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre></div><p>...заставит Sapper запустить <code>preload</code> функцию потенциально следующей страницы, как только пользователь наведёт курсор мыши на ссылку (на десктопе) или тапнет по ней (на мобильном устройстве), вместо того, чтобы ожидать события <code>click</code>, которое приведёт к переходу на эту страницу. Как правило, это даст нам дополнительные пару сотен миллисекунд, что как раз является разницей между быстрым UI, и тем который ощущается как тормозной.</p>\n<blockquote>\n<p><code>rel=prefetch</code> это идиома Sapper, а не стандартный атрибут для элементов <code>&lt;a&gt;</code></p>\n</blockquote>\n<!-- TODO add a function to prefetch programmatically -->","metadata":{"title":"Упреждающая загрузка"},"subsections":[{"slug":"rel_prefetch","title":"rel=prefetch","level":3}],"slug":"Uprezhdayushhaya_zagruzka","file":"08-prefetching.md"},{"html":"<p>До сих пор мы использовали <code>sapper dev</code> для сборки нашего приложения и запуска сервера для разработки. Но когда дело доходит до продакшена, нам нужна автономная оптимизированная сборка.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"sapper_build\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#sapper_build\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tsapper build\n\t\t\t\t\t</h3><p>Эта команда упаковывает ваше приложение в директорию <code>__sapper__/build</code>. (Вы можете указать любую папку, а также изменить некоторые другие параметры — для получения дополнительной информации выполните <code>sapper build --help</code>.)</p>\n<p>На выходе мы получаем Node приложение, которое вы можете запустить из корня проекта командой:</p>\n<div class=''><pre class='language-bash'><code>node __sapper__/build</code></pre></div>","metadata":{"title":"Сборка"},"subsections":[{"slug":"sapper_build","title":"sapper build","level":3}],"slug":"Sborka","file":"09-building.md"},{"html":"<p>Есть немалая часть сайтов, которые по сути своей <em>статичны</em>, то есть им для работы не нужен сервер Express. Вместо этого они могут распространяться в виде статических файлов, что позволяет развёртывать их практически на любом хостинге (вроде <a href=\"https://www.netlify.com/\" target=\"_blank\">Netlify</a> или <a href=\"https://pages.github.com/\" target=\"_blank\">GitHub Pages</a>). Статические сайты, как правило, дешевле в эксплуатации и имеют непервзойденную производительность.</p>\n<p>Sapper позволяет вам <em>экспортировать</em> сайт в статические файлы с помощью одной простой команды <code>sapper export</code>. Кстати, вы прямо сейчас смотрите на экспортированный сайт!</p>\n<p>При этом термин <em>статический</em> не означает, что приложение перестанет быть <em>интерактивным</em> — ваши компоненты Svelte будут работают точно так же, как и обычно, и такие вещи, как маршрутизация на клиенте и упреждающая загрузка, тоже никуда не денутся.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"sapper_export\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#sapper_export\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tsapper export\n\t\t\t\t\t</h3><p>В директории вашего проекта Sapper выполните следующую команду:</p>\n<div class=''><pre class='language-bash'><code><span class=\"hljs-comment\"># npx позволяет использовать локально установленные зависимости</span>\nnpx sapper <span class=\"hljs-built_in\">export</span></code></pre></div><p>Будет создана директория <code>__sapper__/export</code> с готовой сборкой вашего сайта. Вы можете сразу запустить его таким образом:</p>\n<div class=''><pre class='language-bash'><code>npx serve __sapper__/<span class=\"hljs-built_in\">export</span></code></pre></div><p>Перейдите в браузере на адрес <a href=\"http://localhost:5000\" target=\"_blank\">localhost:5000</a> и убедитесь, что ваш сайт работает корректно.</p>\n<p>Вы также можете добавить скрипт в свой файл <code>package.json</code>...</p>\n<div class=''><pre class='language-javascript'><code>{\n\t<span class=\"hljs-string\">\"scripts\"</span>: {\n\t\t...\n\t\t<span class=\"hljs-string\">\"export\"</span>: <span class=\"hljs-string\">\"sapper export\"</span>\n\t}\n}</code></pre></div><p>...что позволит экспортировать ваше приложение командой <code>npm run export</code>.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Kak_eto_rabotaet\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Kak_eto_rabotaet\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tКак это работает\n\t\t\t\t\t</h3><p>Когда вы запускаете <code>sapper export</code>, Sapper сначала создаёт рабочую версию вашего приложения, как происходит при запуске <code>sapper build</code>, и копирует содержимое вашей папки <code>static</code> в место назначения. Затем он запускает сервер и &#39;заходит&#39; на главную страницу получившегося сайта. Оттуда он следует по всем найденным ссылкам из элементов <code>&lt;a&gt;</code> и сохраняет любые данные, предоставляемые приложением.</p>\n<p>По этой причине любые страницы, которые необходимы в экспортированом сайте, должны быть доступны с помощью элементов <code>&lt;a&gt;</code>. Кроме того, любые серверные или иные нестраничные маршруты должны запрашиваться в <code>preload</code>, а <em>не</em> в <code>onMount</code> или ещё где-то.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Kogda_eksportirovat_ne_nuzhno\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Kogda_eksportirovat_ne_nuzhno\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tКогда экспортировать не нужно\n\t\t\t\t\t</h3><p>Основное правило таково: чтобы приложение могло быть экспортировано, любые два пользователя, попадающие на одну и ту же страницу вашего приложения, должны получать одинаковое содержимое с сервера. Другими словами, любое приложение, которое включает в себя пользовательские сессии или аутентификацию, <em>не</em> может быть правильно экспортировано командой <code>sapper export</code>.</p>\n<p>Обратите внимание, что вы всё ещё можете экспортировать приложения с динамическими маршрутами, как в нашем примере <code>src/routes/blog/[slug].html</code>. Команда <code>sapper export</code> будет обрабатывать <code>this.fetch</code> запросы внутри функций <code>preload</code>, поэтому данные, поступающие из <code>src/routes/blog/[slug].json.js</code> тоже будут сохранены.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Konflikty_marshrutov\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Konflikty_marshrutov\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tКонфликты маршрутов\n\t\t\t\t\t</h3><p>Поскольку <code>sapper export</code> создаёт отражение всех маршрутов в виде файлового дерева, то невозможно иметь два <em>серверных маршрута</em>, где возникает ситуация, что директория и файл в одном и том же месте будут иметь одинаковое имя. Например, <code>src/routes/foo/index.js</code> и <code>src/routes/foo/bar.js</code> будут пытаться создать файлы <code>export/foo</code> и <code>export/foo/bar</code>, что приведёт к ошибке.</p>\n<p>Решение состоит в том, чтобы переименовать один из маршрутов и избежать подобного конфликта — например так: <code>src/routes/foo-bar.js</code>. Не забудьте, что при этом придётся подправить код приложения в том месте, где он берёт данные <code>/foo/bar</code>, указав новый маршрут <code>/foo-bar</code>.</p>\n<p>Для <em>маршрутов страниц</em> этой проблемы не возникает, поскольку мы создаём файл <code>export/foo/index.html</code> вместо <code>export/foo</code>.</p>\n","metadata":{"title":"Экспортирование"},"subsections":[{"slug":"sapper_export","title":"sapper export","level":3},{"slug":"Kak_eto_rabotaet","title":"Как это работает","level":3},{"slug":"Kogda_eksportirovat_ne_nuzhno","title":"Когда экспортировать не нужно","level":3},{"slug":"Konflikty_marshrutov","title":"Конфликты маршрутов","level":3}],"slug":"Eksportirovanie","file":"10-exporting.md"},{"html":"<p>Приложения Sapper запускаются везде, где поддерживается работа Node 8 или выше.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Razvyortyvanie_v_Now\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Razvyortyvanie_v_Now\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tРазвёртывание в Now\n\t\t\t\t\t</h3><blockquote>\n<p>Этот раздел описывает работу только с Now 1, а не с Now 2</p>\n</blockquote>\n<p>Мы легко можем развернуть приложение на платформе <a href=\"https://zeit.co/now\" target=\"_blank\">Now</a>:</p>\n<div class=''><pre class='language-bash'><code>npm install -g now\nnow</code></pre></div><p>Эти команды загрузят исходный код в Now, после чего он самостоятельно выполнит <code>npm run build</code> и <code>npm start</code> и даст вам URL, по которому будет располагаться развёрнутое приложение.</p>\n<p>Для других хостингов вам скорее всего нужно будет выполнять <code>npm run build</code> вручную.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Razvyortyvanie_servis-vorkerov\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Razvyortyvanie_servis-vorkerov\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tРазвёртывание сервис-воркеров\n\t\t\t\t\t</h3><p>Sapper обеспечивает уникальность файла сервис-воркера(<code>service-worker.js</code>), путём добавления временной метки в исходный код, которая рассчитывается с использованием функции <code>Date.now ()</code>.</p>\n<p>В окружениях, где приложение разворачивается на нескольких физических серверах (например, <a href=\"https://zeit.co/now\" target=\"_blank\">Now</a>), следует использовать одинаковую временную метку для сервис-воркеров на всех инстансах. В противном случае пользователи могут столкнуться с проблемами, когда сервис-воркер будет неожиданно обновляться, потому что приложение обращается сначала к серверу 1, затем к серверу 2, а метка времени на них будет различаться.</p>\n<p>Чтобы переопределить метку времени Sapper, вы можете использовать переменную среды (например, <code>SAPPER_TIMESTAMP</code>), а затем изменить <code>service-worker.js</code> подобным образом:</p>\n<div class=''><pre class='language-javascript'><code><span class=\"hljs-keyword\">const</span> timestamp = process.env.SAPPER_TIMESTAMP; <span class=\"hljs-comment\">// вместо `import { timestamp }`</span>\n\n<span class=\"hljs-keyword\">const</span> ASSETS = <span class=\"hljs-string\">`cache<span class=\"hljs-subst\">${timestamp}</span>`</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n\t<span class=\"hljs-comment\">/* ... */</span>\n\tplugins: [\n\t\t<span class=\"hljs-comment\">/* ... */</span>\n\t\treplace({\n\t\t\t<span class=\"hljs-comment\">/* ... */</span>\n\t\t\t<span class=\"hljs-string\">'process.env.SAPPER_TIMESTAMP'</span>: process.env.SAPPER_TIMESTAMP || <span class=\"hljs-built_in\">Date</span>.now()\n\t\t})\n\t]\n}</code></pre></div><p>Затем вы можете определить эту переменную при запуске, например:</p>\n<div class=''><pre class='language-bash'><code>SAPPER_TIMESTAMP=$(date +%s%3N) npm run build</code></pre></div><p>При развертовании на <a href=\"https://zeit.co/now\" target=\"_blank\">Now</a>, вы можете передать эту переменную непосредственно в Now:</p>\n<div class=''><pre class='language-bash'><code>now -e SAPPER_TIMESTAMP=$(date +%s%3N)</code></pre></div>","metadata":{"title":"Развёртывание"},"subsections":[{"slug":"Razvyortyvanie_v_Now","title":"Развёртывание в Now","level":3},{"slug":"Razvyortyvanie_servis-vorkerov","title":"Развёртывание сервис-воркеров","level":3}],"slug":"Razvyortyvanie","file":"11-deploying.md"},{"html":"<p>По умолчанию Sapper не добавляет в приложение никаких http-заголовков, касающихся безопасности, но вы можете добавить их самостоятельно, используя прослойку, например <a href=\"https://helmetjs.github.io/\" target=\"_blank\">Helmet</a>.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Politiki_zashhity_kontenta_CSP\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Politiki_zashhity_kontenta_CSP\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tПолитики защиты контента(CSP)\n\t\t\t\t\t</h3><p>Sapper генерирует встроенные в страницу элементы <code>&lt;script&gt;</code>, которые могут не выполняться, если заголовки <a href=\"https://developer.mozilla.org/ru/docs/Web/HTTP/CSP\" target=\"_blank\">Политики защиты контента/Content Security Policy (CSP)</a> запрещают выполнение таких скриптов (<code>unsafe-inline</code>).</p>\n<p>Чтобы обойти это, Sapper может встроить <a href=\"https://www.troyhunt.com/locking-down-your-website-scripts-with-csp-hashes-nonces-and-report-uri/\" target=\"_blank\">nonce</a>, который может быть сконфигурирован для генерации нужных CSP заголовков. Вот пример использования <a href=\"https://expressjs.com/\" target=\"_blank\">Express</a> и <a href=\"https://helmetjs.github.io/\" target=\"_blank\">Helmet</a>:</p>\n<div class=''><pre class='language-javascript'><code><span class=\"hljs-comment\">// server.js</span>\n<span class=\"hljs-keyword\">import</span> uuidv4 <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'uuid/v4'</span>;\n<span class=\"hljs-keyword\">import</span> helmet <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'helmet'</span>;\n\napp.use(<span class=\"hljs-function\">(<span class=\"hljs-params\">req, res, next</span>) =&gt;</span> {\n\tres.locals.nonce = uuidv4();\n\tnext();\n});\napp.use(helmet({\n\t<span class=\"hljs-attr\">contentSecurityPolicy</span>: {\n\t\t<span class=\"hljs-attr\">directives</span>: {\n\t\t\t<span class=\"hljs-attr\">scriptSrc</span>: [\n\t\t\t\t<span class=\"hljs-string\">\"'self'\"</span>,\n\t\t\t\t(req, res) =&gt; <span class=\"hljs-string\">`'nonce-<span class=\"hljs-subst\">${res.locals.nonce}</span>'`</span>\n\t\t\t]\n\t\t}\n\t}\n}));\napp.use(sapper.middleware());</code></pre></div><p>Использование <code>res.locals.nonce</code> подобным образом предусмотрено <a href=\"https://helmetjs.github.io/docs/csp/#generating-nonces\" target=\"_blank\">документацией Helmet по CSP</a>.</p>\n","metadata":{"title":"Безопасность"},"subsections":[{"slug":"Politiki_zashhity_kontenta_CSP","title":"Политики защиты контента(CSP)","level":3}],"slug":"Bezopasnost","file":"12-security.md"},{"html":"<p>Обычно точка входа в приложение Sapper находится в <code>/</code>. Но в некоторых случаях вашему приложению требуется быть доступным по другому базовому пути — например, если Sapper контролирует только часть вашего домена, или у вас несколько приложений Sapper, которые живут рядом друг с другом.</p>\n<p>Это можно сделать таким образом:</p>\n<div class=''><pre class='language-javascript'><code><span class=\"hljs-comment\">// app/server.js</span>\n\nexpress() <span class=\"hljs-comment\">// или Polka, или иной фреймворк</span>\n\t.use(\n\t\t<span class=\"hljs-string\">'/my-base-path'</span>, <span class=\"hljs-comment\">// &lt;!-- добавьте эту строку</span>\n\t\tcompression({ <span class=\"hljs-attr\">threshold</span>: <span class=\"hljs-number\">0</span> }),\n\t\tserve(<span class=\"hljs-string\">'static'</span>),\n\t\tsapper.middleware()\n\t)\n\t.listen(process.env.PORT);</code></pre></div><p>Sapper правильно настроит маршруты как на стороне сервера, так и на стороне клиента для работы с указанным базовым путём.</p>\n<p>Если вы <a href=\"docs#Eksportirovanie\">экспортируете</a> своё приложение, то нужно указать по какому пути искать корень сайта:</p>\n<div class=''><pre class='language-bash'><code>sapper <span class=\"hljs-built_in\">export</span> --basepath my-base-path</code></pre></div>","metadata":{"title":"Базовые URL"},"subsections":[],"slug":"Bazovye_URL","file":"13-base-urls.md"},{"html":"<p>Вы можете использовать любые фреймворки и библиотеки для тестирования по своему вкусу. В <a href=\"https://github.com/sveltejs/sapper-template\" target=\"_blank\">sapper-template</a> по умолчанию используется <a href=\"https://cypress.io\" target=\"_blank\">Cypress</a>.</p>\n\n\t\t\t\t\t<h3>\n\t\t\t\t\t\t<span id=\"Zapusk_testov\" class=\"offset-anchor\" ></span>\n\t\t\t\t\t\t<a href=\"docs#Zapusk_testov\" class=\"anchor\" aria-hidden=\"true\"></a>\n\t\t\t\t\t\tЗапуск тестов\n\t\t\t\t\t</h3><div class=''><pre class='language-bash'><code>npm <span class=\"hljs-built_in\">test</span></code></pre></div><p>Будет запущен сервер и открыт Cypress. Вы можете (и должны!) добавлять свои собственные тесты в <code>cypress/integration/spec.js</code>. Для получения дополнительной информации обратитесь к <a href=\"https://docs.cypress.io/guides/overview/why-cypress.html\" target=\"_blank\">документации</a>.</p>\n","metadata":{"title":"Тестирование"},"subsections":[{"slug":"Zapusk_testov","title":"Запуск тестов","level":3}],"slug":"Testirovanie","file":"14-testing.md"},{"html":"<p>Заниматься отладкой серверного кода особенно просто при помощи <a href=\"https://github.com/GoogleChromeLabs/ndb\" target=\"_blank\">ndb</a>. Установите его глобально ...</p>\n<div class=''><pre class='language-bash'><code>npm install -g ndb</code></pre></div><p>...потом запустите приложение Sapper:</p>\n<div class=''><pre class='language-bash'><code>ndb npm run dev</code></pre></div><blockquote>\n<p>Предполагается, что скрипт <code>npm run dev</code> запускает <code>sapper dev</code>. Вы также можете запустить Sapper через <a href=\"https://blog.npmjs.org/post/162869356040/introduction-npx-an-npm-package-runner\" target=\"_blank\">npx</a> таким образом — <code>ndb npx sapper dev</code>.</p>\n</blockquote>\n<p>Обратите внимание, что в терминале может не быть никакого вывода, пока запускается ndb.</p>\n","metadata":{"title":"Отладка"},"subsections":[],"slug":"Otladka","file":"15-debugging.md"}]